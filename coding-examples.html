<!DOCTYPE html>
<html lang="en-US">
<head>
	<title>Preparing for a Technical Interview</title>
	<meta charset="utf-8">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<style>
header { text-align: center; }
footer { color: gray; }
.item {
	display: inline-block;
	width: 60px;
	font-weight: bold;
}
h3 { color: teal;}
h4 { color: steelblue;}
pre { background-color: #DDDDDD; margin: 5px}
</style>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3662373-7', 'auto');
  ga('send', 'pageview');
</script>
</head>

<body style='width: 900px; margin: 20px; margin: 0 auto'>
<header>
	<div style='font-size: 24pt; font-weight: bold;'>The Technical Interview</div>
	</div>
	<h2 style='color: steelblue'>Coding Examples</h2>
	<h4 style='color: darkgray'>All the examples are hand coded and tested by me. They are not copied from other sources.</h4>
</header>

<p>
The coding examples in this section are basic algorithms. A coding portion of a technical interview will likely start with one of these types
of algorithms. Typically, after asking you to code the basic algorithms, you will be ask to make improvements or other variations. If you are 
unable to pass this part of the coding portion, you will probably not continue to the next round of interview.
</p>

<h3>1. Prime Numbers</h3>
<p>
The most basic coding example you might get asked is to write an algorithm to output a series of prime numbers.
Prime numbers are numbers that are only divisible by one and itself. The algorithm is a 
straight forward iterative algorithm.
</p>
<p>
The number one is a prime number, since it can only be divisible by itself. The
number two is also a prime number, since there are no numbers between one and two
to divide by. Therefore, I generally like to start the iterative process at three, though
you may choose to start it at two.
</p>
<h4>Algorithm</h4>
<ol>
	<li>For each number, we attempt to divide it by every number less than it, except for one.</li>
	<li>The integer modulo operator is used to test if there is a remainder from the integer division.</li>
	<li>If there is no remainder, it is divisible by the number and therefore not a prime.</li>
	<li>If each of the numbers it is divided by has a remainder, it is a prime.</li>
</ol>

<h4>Python</h4>
<pre>

print( "Prime Numbers between 1 and 100")

# Prime Numbers are numbers only divisible by 1 and itself.
print( "1" )	
print( "2" )

# Primes for numbers above 2
for number in range( 3, 101 ):
	# Attempt to divide this number by every number between 2 and one less than itself
	for div in range(2,number):
		# use the mod function to see if their is a remainder in the division
		if ( number % div ) == 0:
			break
	else:
		print(number)
		
</pre>

<h4>Java</h4>
<pre>

public class prime {
	public static void main( String args[] ) {
		System.out.println( "Prime Numbers between 1 and 100");

		// Prime Numbers are numbers only divisible by 1 and itself.
		System.out.println( "1" );
		System.out.println( "2" );

		// Primes for numbers above 2
		for ( int number = 3; number <=100; number++ ) {
			// Attempt to divide this number by every number between 2 and one less than itself
			int div = 2;
			for ( /**/; div < number; div++ ) {
				// use the mod function to see if their is a remainder in the division
				if ( ( number % div ) == 0 )
					break;
			}
			if ( div == number )
				System.out.println(number);
		}
	}
}

</pre>

<p>
Can we make an improvement? Yes. Since we know all even numbers are divisible by two, we
can skip checking even numbers and only check odd numbers. Likewise, since we know odd numbers are not divisible by even numbers,
we can skip dividing by even numbers and only divide by odd numbers.
</p>

<h4>Algorithm - Skip even numbers</h4>
<ol>
	<li>For each odd number, we attempt to divide it by every odd number less than it, except for one and two.</li>
	<li>The integer modulo operator is used to test if there is a remainder from the integer division.</li>
	<li>If there is no remainder, it is divisible by the number and therefore not a prime.</li>
	<li>If each of the numbers it is divided by has a remainder, it is a prime.</li>
</ol>

<h4>Python</h4>
<pre>

print( "Prime Numbers between 1 and 100")

# Prime Numbers are numbers only divisible by 1 and itself.
print( "1" )	
print( "2" )	
print( "3" )

# Primes for numbers above 5
for number in range( 5, 101, 2 ):
	# Attempt to divide this number by every odd number between 2 and one less than itself
	for div in range(3,number,2):
		# use the mod function to see if their is a remainder in the division
		if ( number % div ) == 0:
			break
	else:
		print(number)
		
</pre>

<h4>Java</h4>
<pre>

public class prime {
	public static void main( String args[] ) {
		System.out.println( "Prime Numbers between 1 and 100");

		// Prime Numbers are numbers only divisible by 1 and itself.
		System.out.println( "1" );
		System.out.println( "2" );
		System.out.println( "3" );

		// Primes for numbers above 5
		for ( int number = 5; number <=100; number += 2 ) {
			int div = 3;
			// Attempt to divide this number by every odd number between 3 and one less than itself
			for ( /**/; div < number; div += 2 ) {
				// use the mod function to see if their is a remainder in the division
				if ( ( number % div ) == 0 )
					break;
			}
			if ( div == number )
				System.out.println(number);
		}
	}
}

</pre>

<p>
Can we make another improvement? Yes. Since we are skipping even numbers, we know that each number to be prime must be divisible by at least the number three.
Therefore, any divisible number must be one-third or less the value of the number. We can cut down on the number of iterations by only dividing
the first 1/3 of values less than the number.
</p>

<h4>Algorithm - Skip even numbers, and divide only by numbers one-third or less than the number.</h4>
<ol>
	<li>For each odd number, we attempt to divide it by every odd number that is less than one-third of the number, except for one and two.</i>
	<li>The integer modulo operator is used to test if there is a remainder from the integer division.</li>
	<li>If there is no remainder, it is divisible by the number and therefore not a prime.</li>
	<li>If each of the numbers it is divided by has a remainder, it is a prime.</li>
</ol>

<h4>Python</h4>
<pre>

print( "1" )	
print( "2" )	
print( "3" )
for number in range( 5, 101, 2 ):
	# Attempt to divide this number by every number between 3 and one third less than itself
	third = int( (number / 3 ) ) + 1
	for div in range(3,third,2):
		# use the mod function to see if their is a remainder in the division
		if ( number % div ) == 0:
			break
	else:
		print(number)
		
</pre>

<h4>Java</h4>
<pre>

public class prime {
	public static void main( String args[] ) {
		System.out.println( "Prime Numbers between 1 and 100");

		// Prime Numbers are numbers only divisible by 1 and itself.
		System.out.println( "1" );
		System.out.println( "2" );
		System.out.println( "3" );

		// Primes for numbers above 5
		for ( int number = 5; number <=100; number += 2 ) {
			int div = 3;
			int third = ( number / 3 );	// calculate one-third of the number
			// Attempt to divide this number by every number between 3 and one third of the number
			for ( /**/; div <= third; div += 2) {
				// use the mod function to see if their is a remainder in the division
				if ( ( number % div ) == 0 )
					break;
			}
			if ( div >= third )
				System.out.println(number);
		}
	}
}

</pre>

<h3>2. Fibonacci Sequence</h3>
<p>
One of the most common and basic coding examples is to code a solution for the Fibonacci sequence. A Fibonacci sequence is a function where F(N) equals
F(n-1) + F(n-2); that is the summation of the previous two values in the sequence. Originally, the seed sequence was F(0) = 1 and F(1) = 1, but modern
solutions use F(0) = 0 and F(1) = 1. This sequence can be written in a very short recursive algorithm.
</p>

<h4>Algorithm - Recursive</h4>
<ul>
	<li>If n = 0, then return 0.</li>
	<li>If n = 1, then return 1.</li>
	<li>If n > 1, return the sum of F(n-1) + F(n-2)</li>
</ul>

<h4>Python</h4>

<pre>

# Fibonacci Sequence
# Is a sum (addition) of the previous two numbers in the sequence, as
#	F(n) = F(n-1) + F(n-2)
# Where
# 	F(0) = 0 and F(1) = 1
# Hence 
#	F(2) = 0 + 1 [F(1) + F(0)] = 1
#	F(3) = 1 + 1 [F(2) + F(1)] = 2

# Recursive Solution
def Fibonacci(n):
	# F(0) and F(1) case
	if n==0:
		return 0
	if n==1:
		return 1
	return Fibonacci(n-1) + Fibonacci(n-2)

# Fibonacci Sequence to F(10)
for number in range( 0, 10 ):
	print( Fibonacci(number) )
	
</pre>

<h4>Java</h4>
<pre>

public class fibonacci {
	public static void main( String args[] ) {
		System.out.println( "Fibonacci Sequence to F(10)");

		for ( int number = 0; number < 10; number++ )
			System.out.println( Fibonacci( number ) );

	}
	
	// Recursive Solution
	public static int Fibonacci( int n) {
		if ( n == 0 ) return 0;
		if ( n == 1 ) return 1;
		return Fibonacci( n - 1 ) + Fibonacci( n - 2 );
	}
}

</pre>

<p>
It is common to be asked if you can write the algorithm for an iterative solution (looping - no recursion).
</p>

<h4>Algorithm - Iterative</h4> 
<ul>
	<li>If n = 0, then return 0.</li>
	<li>If n = 1, then return 1.</li>
	<li>If n > 1, then set last F(n-2) = 0, and last F(n-1) = 0, and F(n) initialized to zero.</li>
	<li>Loop from 2 to n.
		<ul>
			<li>Set current F(n) to current F(n-1) + F(n-2).</li>
			<li>Set F(n-2) to current F(n-1).</li>
			<li>Set F(n-1) to current F(n).</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>

def FibonacciIterative(n):
	# F(0) and F(1) case
	if n==0:
		return 0
	if n==1:
		return 1
	fn	  = 0	# current value for F(n)
	f_minus_1 = 1	# current value for F(n-1)
	f_minus_2 = 0	# current value for F(n-2)
	for i in range( 2, n+1 ):
		fn        = f_minus_1 + f_minus_2   # F(n) = F(n-1) + F(n-2)
		f_minus_2 = f_minus_1               # next F(n-2)
		f_minus_1 = fn                      # next F(n-1)
	return fn
		
# Fibonacci Sequence to F(10)
for number in range( 0, 10 ):
	print( FibonacciIterative(number) )
	
</pre>

<h4>Java</h4>
<pre>

public class fibonacci {
	public static void main( String args[] ) {
		System.out.println( "Fibonacci Sequence to F(10)");

		for ( int number = 0; number < 10; number++ )
			System.out.println( Fibonacci( number ) );
	}
	
	// Iterative Solution	
	public static int Fibonacci( int n ) {
		if ( n == 0 ) return 0;
		if ( n == 1 ) return 1;

		int fn	      = 0;	// current value for F(n)		
		int f_minus_2 = 0;	// current value of F(n-2)
		int f_minus_1 = 1;	// current value of F(n-1)
		for ( int i = 2; i <= n; i++ ) {
			fn        = f_minus_1 + f_minus_2;  // F(n) = F(n-1) + F(n-2)
			f_minus_2 = f_minus_1;              // next F(n-2)
			f_minus_1 = fn;                     // next F(n-1)
		}
		return fn;
	}
}

</pre>

<h3>3. Dynamic Arrays</h3>
<p>
A dynamic array is an array that can be resized, can be randomly accessed via an cardinal ordering, where there is a one-to-one relationship
between an integer index and a value. For example, if a dynamic array cans the ordered elements A, B and D, they would be accessed (one-to-one relationship)
by indices 0=>A, 1=>B and 2=>D. If we insert a C between B and D, the ordering would be rearranged but there still would be a one-to-one relationship, accessed
as indices 0=>A, 1=>B, 2=>C and 3=>D. Note how index 2 now relates to C and index 3 to D.
</p>

<p>
You maybe asked to implement a dynamic array using a class. You would be expected to implement at least and Add() and Get() methods.

<h4>Algorithm</h4>
<ul>
	<li>Define a class for an element.
		<ul>
			<li>Has a member to hold the value</li>
			<li>Has a next pointer for the next element in the array.</li>
		</ul>
	</li>
	<li>Define a class for an array.
		<ul>
			<li>Has a member to hold the head and a member to hold the tail of the array.</li>
			<li>A member to hold the size of the array.</li>
			<li>Define a Add method.
				<ul>
					<li>Instantiate a new element.</li>
					<li>Add the element to the end of tail (the tail's next pointer) and update the tail to the new element.</li>
					<li>If it is the first element in the array, set the head to the new element.</li>
					<li>Increment the size of the array by one.</li>
				</ul>
			</li>
			<li>Define a Get method.</li>
				<ul>
					<li>Check for array out of bounds condition.</li>
					<li>Starting with the head, advance consecutively index' number of times following the next pointer.</li>
					<li>Return the value of the current element.</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>

# Definition for an element in the dynamic array
class Element:
	# Constructor: set the node data
	def __init__(self, value):
		self.value   = value	# node data

# Definition for a Dynamic Array
class DynamicArray:
	# The size (number of elements) of the array
	def Size():
		return size;

	# Add an element to the end of the dynamic array
	def Add( value ):
		e = Element(value)
		
		# Set the next element of the previous tail to the new element
		if tail != None:
			tail.next = e

		# set the current tail to the new element
		tail = e
		
		# If there is no head (first element), set the head to the new element.
		if head == None:
			head = e
		
		# Increment the size of the array
		size += 1
		
	# Get the value at the corresponding index
	def Get( index ):
		# Check for out of bounds condition
		if index > size - 1 or index < 0:
			return None
			
		# Step (linear) to the index position
		curr = head;
		for i in range( 0, index ):
			curr = curr.next
			
		return curr.value
		
</pre>

<h4>Java</h4>
<pre>

// Definition for an element in the dynamic array
class Element {
	Object  value = null;	// Element value
	Element next  = null;	// Next element in the array
	
	// Constructor
	public Element( Object value ) {
		this.value = value;
	}
}

// Definition for a Dynamic Array
class DynamicArray {
	private Element head = null;	// Head of the Array
	private Element tail = null;	// Tail of the Array
	private int     size = 0;
	
	// The size (number of elements) of the array
	public int Size() {
		return size;
	}
	
	// Add an element to the end of the dynamic array
	public void Add( Object value ) {
		Element e = new Element( value );
		
		// Set the next element of the previous tail to the new element
		if ( tail != null ) 
			tail.next = e;
			
		// set the current tail to the new element
		tail = e;
		
		// If there is no head (first element), set the head to the new element.
		if ( head == null )
			head = e;
			
		// Increment the size of the array
		size++;
	}

	// Get the value at the corresponding index
	public Object Get( int index ) {
		// Check for out of bounds condition
		if ( index > size - 1 || index < 0 )
			return null;
			
		// Step (linear) to the index position
		Element curr = head;
		for ( int i = 0; i < index; i++ )
			curr = curr.next;
			
		return curr.value;
	}
}

</pre>

<p>Once you've solved the Add() and Get() methods, you will likely be asked to code the methods for Delete() and Insert(). In the below coding
example, I solve for an insert after. You maybe additionally asked to code an insert before, or both.
</p>

<h4>Algorithm</h4>
<ul>
	<li>Define a Delete() method.
		<ul>
			<li>Check for array out of bounds condition.</li>
			<li>If deleting the head (index = 0), the set the new head to what the head currently points to.</li>
			<li>Starting with the head, advance consecutively index' number of times following the next pointer,
			and remember the element before it.</li>
			<li>Set the next pointer of the element before this element to this element's next pointer 
			(thus dropping this element which is in between).</li>
			<li>Decrement the size of the array.</li>
			<li>If the element deleted was the tail (index equals the new array size), set the tail to the previous element.</li>
		</ul>
	</li>
	<li>Define a Insert() after method.
		<ul>
			<li>Check for array out of bounds condition.</li>
			<li>If inserting after the tail (index == size-1), then insert the element using the Add() method.</li>
			<li>Advance to the element at the specified index, and remember the element before it.</li>
			<li>Instantiate a new element.</li>
			<li>Set the next pointer of the new element to the element following the current element.</li>
			<li>Update the next pointer of the current element to the new element (thus inserting in between).</li>
			<li>Increment the size of the array by one.</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>
</pre>

<h4>Java</h4>
<pre>

// Definition for a Dynamic Array
class DynamicArray {
	...
	
	public boolean Delete( int index ) {
		// Check for out of bounds condition
		if ( index > size - 1 || index < 0 )
			return false;
		
		// Remove the head of the dynamic array
		if ( index == 0 ) {
			// Set the head to the next head
			head = head.next;
			
			// If the array is now empty, set the tail to null
			if ( --size == 0 )
				tail = null;
			
			return true;
		}
		
		// Find the element at the specified index, and remember the element before it.
		Element curr = head, prev = null;
		for ( int i = 0; i < index; i++ ) {
			prev = curr;
			curr = curr.next;
		}
		
		// Set the next pointer of the previous element to the next pointer of the current element,
		// thus dropping this element which is between them.
		prev.next = curr.next;
		
		// We deleted the tail. Set the current tail to the previous element.
		if ( --size == index )
			tail = prev;
			
		return true;
	}
	
	public boolean Insert( int index, Object value ) {
		// Check for out of bounds condition
		if ( index > size - 1 || index < 0 )
			return false;
			
		// Adding to the tail
		if ( index == size-1 ) {
			Add( value );
			return true;
		}
		
		// Find the element at the index
		Element curr = head;
		for ( int i = 0; i < index; i++ ) 
			curr = curr.next;

		// Insert (after) between the current element and the next
		Element e = new Element( value );
		e.next = curr.next;
		curr.next = e;
		
		size++;
		return true;
	}
		
	def Insert( index, value ):
		# Check for out of bounds condition
		if index > size - 1 or index < 0:
			return false
			
		# Adding to the tail
		if index == size-1:
			Add( value )
			return true
		
		# Find the element at the index
		curr = head
		for i in range( 0, index ):
			curr = curr.next

		# Insert (after) between the current element and the next
		e = Element( value )
		e.next = curr.next
		curr.next = e
		
		size += 1
		return true
	....
}

</pre>

<h3>4. Linked Lists - Queue</h3>
<p>
A linked list is a data structure where each element is linked to another element forming a chain, such as A links to B which links to C, and so forth.
Depending on the type of chaining, one can use link lists to code queues and stacks. A queue is also known as a FIFO (first-in-first-out) structure.
</p>
<p>
A queue consists of a head and a tail, where the head points to the first element in the queue, and the tail points to the end of the queue. Each new element
is added to the end of the tail, becoming the new tail. Throughout the chain, each element is linked to the next element starting from the head and
proceeding to the tail (forward chaining). A queue is typically used to process elements in the same sequential order they were added (FIFO). To process
an element, one removes the head (current element to process) of the queue and sets the new head to the next element following the previous head.
<p>

<h4>Algorithm - Queue</h4>
<ul>
	<li>Define a Task object
		<ul>
			<li>Define members for task to perform and next pointer for next element in the forward chain.</li>
			<li>Define a constructor to instantiate a Task.</li>
			<li>Define Next() methods to get and set the next element in the forward chain.</li>
			<li>Define an Action() method to process the element's task.</li>
		</ul>
	</li>
	<li>Define a Queue object
		<ul>
			<li>Define members for the head and tail of the queue.</li>
			<li>Define an Empty() method to test if the queue is empty.</li>
			<li>Define an Add() method to add a task to the tail of the queue.</li>
			<li>Define a Pop() method to process the task at the head of the queue and then set the head of the queue to the next element.</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>

# Definition for a Task element in a Queue
class Task:
	next = None
	
	# constructor, task represents the task to be performed
	def __init__( self, task ):
		self.task = task
	
	# Get the next task this element is chained to
	def GetNext(self):
		return self.next
	
	# Set the next task this element is chained to
	def Next( self, task ):
		self.next = task
	
	# Action to take when task is processed
	def Action( self ):
		print( self.task )
		
# Definition for a Queue
class Queue:
	head = None
	tail = None
	
	# Check if Queue is empty
	def Empty(self):
		if self.head == None:
			return True
		return False
	
	# Add a task to the queue
	def Add( self, task ):
		# the queue is empty, set head and tail to the task
		if self.Empty():
			self.head = self.tail = task
		# otherwise, add it as the new tail
		else:
			self.tail.Next( task )
			self.tail = task
	
	# Remove the top of the queue and process the task
	def Pop( self):
		# Queue is empty
		if self.Empty():
			return
			
		# Process the task here
		self.head.Action()
		
		# Move the head to the next element.
		self.head = self.head.GetNext()
		if self.Empty():
			self.tail = None

print("Process in sequential order tasks: A, B and C" )
queue = Queue()
queue.Add( Task( "A" ) )
queue.Add( Task( "B" ) )
queue.Add( Task( "C" ) )
queue.Pop()
queue.Pop()
queue.Pop()

</pre>

<h4>Java</h4>
<pre>

// Definition for a Task element in a Queue
class Task {
	private Object task;        // the task to perform
	private Task   next = null; // the next task in the queue
	
	// constructor, task represents the task to be performed
	public Task( Object task ) {
		this.task = task;
	}
	
	// Get the next task this element is chained to
	public Task Next() {
		return next;
	}
	
	// Set the next task this element is chained to
	public void Next( Task task ) {
		next = task;
	}
	
	// Action to take when task is processed
	public void Action() {
		System.out.println( task );
	}
}

// Definition for a Queue
public class Queue {
	private Task head = null;	// the head of the queue
	private Task tail = null;	// the tail of the queue
	
	// Check if Queue is empty
	private boolean Empty() {
		if ( head == null )
			return true;
		return false;
	}
	
	// Add a task to the queue
	public void Add( Task task ) {
		// the queue is empty, set head and tail to the task
		if ( Empty() ) {
			head = tail = task;
		}
		// otherwise, add it as the new tail
		else {
			tail.Next( task );
			tail = task;
		}
	}
	
	// Remove the top of the queue and process the task
	public void Pop() {
		// Queue is empty
		if ( Empty() )
			return;
			
		// Process the task here
		head.Action();
		
		// Move the head to the next element.
		head = head.Next();
		if ( Empty() )
			tail = null;
	}
	
	public static void main(String[] args) {
		System.out.println("Process in sequential order tasks: A, B and C" );
		Queue queue = new Queue();
		queue.Add( new Task( "A" ) );
		queue.Add( new Task( "B" ) );
		queue.Add( new Task( "C" ) );
		queue.Pop();
		queue.Pop();
		queue.Pop();
	}
}

</pre>

<p>
You may be asked to improve the coding example by being ask to add a task priority and sort the queue according to the task's priority.
</p>

<h4>Algorithm - Queue with Task Priority</h4>
<ul>
	<li>Define a Task object
		<ul>
			<li>Define members for task to perform, the task's priority and next pointer for next element in the forward chain.</li>
			<li>Define a constructor to instantiate a Task.</li>
			<li>Define Priority() methods to get and set the task's priority.</li>
			<li>Define Next() methods to get and set the next element in the forward chain.</li>
			<li>Define an Action() method to process the element's task.</li>
		</ul>
	</li>
	<li>Define a Queue object
		<ul>
			<li>Define members for the head of the queue (a tail is not needed anymore).</li>
			<li>Define an Empty() method to test if the queue is empty.</li>
			<li>Define an Add() method to add a task to the tail of the queue.</li>
			<li>Define an Insert() method to add a task into the queue based on the task's priority.</li>
			<li>Define a Pop() method to process the task at the head of the queue and then set the head of the queue to the next element.</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>
</pre>

<h4>Java</h4>
<pre>

// Definition for a Task element in a Queue
class Task {
	private Object task;        // the task to perform
	private Task   next = null; // the next task in the queue
	private int    priority;    // the task's priority
	
	// constructor, task represents the task to be performed
	public Task( Object task, int priority ) {
		this.task = task;
		this.priority = priority;
	}
	
	// Get the task's priority
	public int Priority() {
		return priority;
	}
	
	// Set the task's priority
	public void Priority( int priority ) {
		this.priority = priority;
	}
	
	// Get the next task this element is chained to
	public Task Next() {
		return next;
	}
	
	// Set the next task this element is chained to
	public void Next( Task task ) {
		next = task;
	}
	
	// Action to take when task is processed
	public void Action() {
		System.out.println( task );
	}
}

// Definition for a Queue
public class Queue {
	private Task head = null;	// the head of the queue
	
	// Check if Queue is empty
	private boolean Empty() {
		if ( head == null )
			return true;
		return false;
	}
	
	// Add a task to the queue
	public void Add( Task task ) {
		// the queue is empty, set head to the task
		if ( Empty() ) {
			head = task;
		}
		// otherwise, insert the task into the queue according to the task's priority
		else {
			Insert( task );
		}
	}
	
	// Insert a task into the queue based on priority
	private void Insert( Task task ) {
		// Start at the head of the chain to search where to insert the task
		Task curr = head, prev = head;
		while ( curr != null ) {
			// Find a task whose's priority is less than the new task
			if ( task.Priority() > curr.Priority() ) {
				// Insert the task in front of the current task.
				task.Next( curr );
				
				// If inserting in front of the head of the queue, 
				// make the new task the head of the queue
				if ( curr == head )
					head = task;
				// Otherwise, set the previous element's next to the new task
				else {
					prev.Next( task );
				}
				break;
			}
			
			prev = curr;
			curr = curr.Next();
		}
		
		// Add to the tail (end) of the queue
		if ( curr == null ) {
			prev.Next( task );
		}
	}
	
	// Remove the top of the queue and process the task
	public void Pop() {
		// Queue is empty
		if ( Empty() )
			return;
			
		// Proces the task here
		head.Action();
		
		// Move the head to the next element.
		head = head.Next();
	}
	
	public static void main(String[] args) {
		System.out.println("Process in priority order tasks: B, C and A" );
		Queue queue = new Queue();
		queue.Add( new Task( "A", 1 ) );
		queue.Add( new Task( "B", 3 ) );
		queue.Add( new Task( "C", 2 ) );
		queue.Pop();
		queue.Pop();
		queue.Pop();
	}
}

</pre>

<p>
You maybe further asked to make another improvement to dynamically change a priority of task and resort the queue accordingly.
</p>

<h4>Algorithm - Queue with Dynamic Priority Update</h4>
<ul>
	<li>Update the priority of the task.</li>
	<li>Locate task in the queue and remove the task.</li>
	<li>Add the task back in.</li>
</ul>

<h4>Python</h4>
<pre>
</pre>

<h4>Java</h4>
<pre>

// Definition for a Queue
public class Queue {
	...
	
	// Update the priority of the task and resort the queue
	public void Update( Task task, int priority ) {
		// Update the task's priority
		task.Priority( priority );
		
		// If the task is the head of the queue, remove it and update head to the next element
		if ( head == task ) {
			head.Next( head.Next() );
		}
		// Find the task in the queue
		else {
			Task curr = head.Next(), prev = head;
			while ( curr != null ) {
				// Remove the task from the queue and update previous element's next to this task's next element
				if ( task == curr ) {
					prev.Next( curr.Next() );
					break;
				}
			}
		}
		
		// Add the task back to the queue
		Add( task );
	}
	
	public static void main(String[] args) {
		System.out.println("Process in priority order tasks: C, B and A" );
		Queue queue = new Queue();
		queue.Add( new Task( "A", 1 ) );
		queue.Add( new Task( "B", 3 ) );
		Task task =  new Task( "C", 2 );
		queue.Add( task );
		queue.Update( task, 4 );
		queue.Pop();
		queue.Pop();
		queue.Pop();
	}
	...
}

</pre>

<h3>5. Linked Lists - Stacks</h3>
<p>
A linked list is a data structure where each element is linked to another element forming a chain, such as A links to B which links to C, and so forth.
Depending on the type of chaining, one can use link lists to code queues and stacks. A stack is also known as a LIFO (last-in-first-out) structure.
while a stack is also known as a LIFO (last-in-last-out) structure.
</p>
<p>
A stack consists of a top, which points to the top of the stack. Each new element
is added to the top of the stack, becoming the new top. Throughout the chain, each element is linked to the next element starting from the top and
proceeding to the bottom (forward chaining). A stack is typically used to process elements in the reverse sequential order they were added (LIFO). To process
an element, one removes the top(current element to process) of the queue and sets the new top to the next element following the previous top.
<p>

<h4>Algorithm - Stack</h4>
<ul>
	<li>Define a Task object
		<ul>
			<li>Define members for task to perform, and next pointer for next element in the forward chain.</li>
			<li>Define a constructor to instantiate a Task.</li>
			<li>Define Next() methods to get and set the next element in the forward chain.</li>
			<li>Define an Action() method to process the element's task.</li>
		</ul>
	</li>
	<li>Define a Stack object
		<ul>
			<li>Define member for the top of the stack.</li>
			<li>Define an Empty() method to test if the stack is empty.</li>
			<li>Define a Push() method to add a task to the top of the stack.</li>
			<li>Define a Pop() method to process the task at the top of the stack and then set the top of the stack to the next element.</li>
		</ul>
	</li>
</ul>

<h4>Python</h4>
<pre>

# Definition for a Task element in a Stack
class Task:
	task = None  # the task to perform
	next = None  # the next task in the stack

	# constructor, task represents the task to be performed
	def __init__( self, task ):
		self.task = task
	
	# Get the next task this element is chained to
	def GetNext(self):
		return self.next
	
	# Set the next task this element is chained to
	def Next( self, task ):
		self.next = task;
	
	# Action to take when task is processed
	def Action( self ):
		print( self.task )

# Definition for a Stack
class Stack:
	top = None   # top of the stack
	
	# Check if the Stack is empty
	def Empty(self):
		if self.top == None:
			return True
		return False
	
	# Push the task to the top of the stack
	def Push( self, task ):
		# Set the task next pointer to the current top
		task.Next( self.top )
		# Set the top to this task
		self.top = task
	
	# Pop the task from the top of the stack
	def Pop( self ):
		# Stack is Empty
		if self.Empty():
			return

		# Perform the action for the task
		self.top.Action()
		
		# Move the top to the current top's next pointer.
		self.top = self.top.GetNext()

print("Process tasks in order: A, B and C" )
stack = Stack()
stack.Push( Task( "C" ) )
stack.Push( Task( "B" ) )
stack.Push( Task( "A" ) )
stack.Pop()
stack.Pop()
stack.Pop()

</pre>

<h4>Java</h4>
<pre>

// Definition for a Task element in a Stack
class Task {
	private Object task;        // the task to perform
	private Task   next = null; // the next task in the stack

	// constructor, task represents the task to be performed
	public Task( Object task ) {
		this.task = task;
	}
	
	// Get the next task this element is chained to
	public Task Next() {
		return next;
	}
	
	// Set the next task this element is chained to
	public void Next( Task task ) {
		next = task;
	}
	
	// Action to take when task is processed
	public void Action() {
		System.out.println( task );
	}
}

// Definition for a Stack
public class Stack {
	private Task top;	// top of the stack
	
	// Check if the Stack is empty
	private boolean Empty() {
		if ( top == null )
			return true;
		return false;
	}
	
	// Push the task to the top of the stack
	public void Push( Task task ) {
		// Set the task next pointer to the current top
		task.Next( top );
		// set the top to this task
		top = task;
	}
	
	// Pop the task from the top of the stack
	public void Pop() {
		// Stack is Empty
		if ( Empty() )
			return;
			
		// Perform the action for the task
		top.Action();
		
		// Move the top to the current top's next pointer.
		top = top.Next();
	}

	public static void main(String[] args) {
		System.out.println("Process tasks in order: A, B and C" );
		Stack stack = new Stack();
		stack.Push( new Task( "C" ) );
		stack.Push( new Task( "B" ) );
		stack.Push( new Task( "A" ) );
		stack.Pop();
		stack.Pop();
		stack.Pop();
	}
}

</pre>

<p>
A common variation you maybe asked is to redesign your stack into a chain of stacks of fixed size. When an element is pushed to a stack
that has reached it's maximum (fixed) size, the bottom if the stack is removed and pushed to the top of the next stack on the chain
and so forth. Likewise, when an element is popped from the stack, the top of the next stack that is chained to it is popped and added
to the bottom of the stack, and so forth.
</p>
<p>
Unlike the previous stack example, where we implicitly performed the task when it was popped, we will this time return the task on a pop and
let the application explicitly invoke performing the task. This will simplify the push and pop operations in a chain.
</p>

<h4>Algorithm - Chain of Stacks</h4>
<ul>
	<li>Define a Task object
		<ul>
			<li>Define members for task to perform, and next and previous pointer for next and previous element in the forward and backward chain.</li>
			<li>Define a constructor to instantiate a Task.</li>
			<li>Define Next() and Prev() methods to get and set the next and previous elements in the forward and backward chain.</li>
			<li>Define an Action() method to process the element's task.</li>
		</ul>
	</li>
	<li>Define a Stack Chain object
		<ul>
			<li>Define members for the top, bottom , maximum size and current size of the stack.</li>
			<li>Define a member for the next stack in the chain.</li>
			<li>Define an Empty() method to test if the stack is empty.</li>
			<li>Define a Push() method to add a task to the top of the stack.
				<ul>
					<li>If exceeds the maximum size of the stack, remove the bottom task of the stack.</li>
					<li>Push the task removed from the bottom to the next stack in the chain.</li>
				</ul>
			</li>
			<li>Define a Pop() method to return the top of the stack and then set the top of the stack to the next element.
				<ul>
					<li>If the next stack in the chain is non-empty, then pop the top of the next stack in the chain.</li>
					<li>Push the task removed from the top of the next stack in the chain onto this stack.</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

<h4>Java</h4>
<pre>

// Definition for a Task element in a Stack
class Task {
	...
	private Task   prev = null; // the previous task in the stack
	
	// Get the previous task this element is chained to
	public Task Prev() {
		return prev;
	}
	
	// Set the previous task this element is chained to
	public void Prev( Task task ) {
		prev = task;
	}
	...
}

// Definition for a Chain of Stacks
public class StackChain {
	private Task top    = null;      // top of the stack
	private Task bottom = null;      // bottom of the stack
	private final int max;           // maximum size of the stack
	private int size;                // current size of the stack
	private StackChain chain = null; // next stack in the chain
	
	// Constructor: instantiate a stack in a chain, specifying the maximum size of the stack.
	public StackChain( int max ) {
		this.max = max;
	}
	
	// Check if the Stack is empty
	private boolean Empty() {
		if ( top != null )
			return false;
		return true;
	}
	
	// Push the task to the top of the stack
	public void Push( Task task ) {
		// Set the task next pointer to the current top
		task.Next( top );
		
		// Chain the current top back to the task
		if ( top != null )
			top.Prev( task );
			
		// Set the top to this task
		top = task;
		
		// only element on the stack, set the bottom to the top
		if ( ++size == 1 )
			bottom = top;
			
		// overflowed the maximum size of the stack
		if ( size > max ) {
			// Create a new stack in the chain of the same maximum size
			if ( chain == null )
				chain = new StackChain( max );
			
			// Push the bottom of this stack onto the top of the next stack in the chain
			chain.Push( bottom );
			
			// Remove the bottom by setting the bottom to the previous element from the bottom
			bottom = bottom.Prev();
		}
	}
	
	// Pop the task from the top of the stack
	public Task Pop() {
		// Stack is Empty
		if ( Empty() )
			return null;
			
		// The task that is being popped from the stack
		Task task = top;
		
		// Stack is empty
		if ( --size == 0 )
			top = bottom = null;
		else {
			// Move the top to the current top's next pointer.
			top = top.Next();
			
			// There is a another stack chained to this stack
			if ( chain != null ) {
				// Pop the top of the stack chained to this stack
				Task move = chain.Pop();
				
				// Add this task to the bottom of the stack
				bottom.Next( move );
				// Set the task's next to null
				task.Next( null );
				// Set the task as the new bottom of the stack
				bottom = move;
				
				// If the stack chained to this one is empty, set the chain pointer to null
				if ( chain.Empty() )
					chain = null;
			}
		}
		
		// return the task that was popped
		return task;
	}
	
	public static void main(String[] args) {
		System.out.println("Process tasks in order: 6, 5, 4, 3, 2, 1, 0" );
		StackChain stack = new StackChain( 3 );
		for ( int i = 0; i < 7; i++ )
			stack.Push( new Task( i ) );
		for ( int i = 0; i < 7; i++ )
			stack.Pop().Action();
	}
}

</pre>


<h3>6. Binary Tree</h3>

<p>
A binary tree is a tree where each node contains at most two branches (subtrees), commonly known as the left tree and right tree. The recursive
definition is a binary tree is either empty or a single node, where the left and right branches are binary subtrees.
</p>
<pre>
binary tree:    empty node |  
                node
                    left binary subtree
                    right binary subtree
</pre>
<p>
Some other terminology that is useful to know:
<ul>
	<li>The topmost node is the root.</li>
	<li>Nodes at the same level are siblings.</li>
	<li>Nodes with no branches are leaf nodes (or leaves).</li>
	<li>Every node with branches is a parent. The nodes are the branches are children.<li>
	<li>A branch is a directed edge.</li>
	<li>A node depth is the number of edges between the root and the node.</li>
	<li>A node height is the number of edges between the node and the deepest leaf node.</li>
</ul>
</p>

<p>
You may be asked to code a class definition for a binary tree node. The binary tree node will have the following members/methods:
<ul>
	<li>Constructor for instantiating the node and initializing the node data. In my examples, I use the data type 'Object' (Java) to indicate that
	the node is not limited to the type of data it can hold, which is determined at run-time.</li>
	<li>Private member fields (only accessible by the class object) for the data value, left and right subtrees.</li>
	<li>Public Set and Get accessors for the data value, left and right subtrees, which can be used by a program accessing the class object.</li>
</ul> 
</p>

<h4>Python</h4>
<pre>

class BinaryTree:
	# Constructor: set the node data and left/right subtrees to null
	def __init__(self, key):
		self.__left  = None	# left binary subtree
		self.__right = None	# right binary subtree
		self.__key   = key	# node data

	# Set Left Binary Subtree
	def Left(self, left):
		self.__left = left

	# Get Left Binary Subtree
	def GetLeft(self ):
		return __left

	# Set Right Binary Subtree
	def Right(self, right):
		self.__right = right

	# Get Right Binary Subtree
	def GetRight(self):
		return __right

	# Set Node Data
	def Key(self, key):
		self.__key = key

	# Get Node Data
	def GetKey(self):
		return __key
		
</pre>

<h4>Java</h4>
<pre>

// Binary Tree Class
class BinaryTree {
    private Object key;         // node data
    private BinaryTree left;    // left binary subtree
    private BinaryTree right;   // right binary subtree
	
	// Constructor: set the node data and left/right subtrees to null
	public BinaryTree (Object key) {
		this.key = key;
		right = null;
		left = null;
	}
	
	// Set the left binary subtree
	public void Left( BinaryTree left ) {
		this.left = left;
	}
	
	// Get the left binary subtree
	public BinaryTree Left() {
		return left;
	}
	
	// Set the right binary subtree
	public void Right( BinaryTree right ) {
		this.right = right;
	}
	
	// Get the right binary subtree
	public BinaryTree Right() {
		return right;
	}
	
	// Set the node data
	public void Key( Object key ) {
		this.key = key;
	}
	
	// Get the node data
	public Object Key() {
		return key;
	}
}

</pre>

<p>You maybe asked for a more generalized representation, such as defining a hierarchical class structure where a binary tree is a class type
of a k-ary tree. For this, we would define a base (super) class with methods common to k-ary trees, and then derive (extend) a binary tree 
class from the base (super) class with methods specific to a binary tree.
</p>
<ul>
	<li>The base class defines the key member and corresponding access methods.</li>
	<li>The base class is made abstract, so that one has to derive (extend) a class to use it.</li>
	<li>An abstract method (must be defined in derived class) is added to defining an action to perform on each node in the tree that is
	specific to a derived class.</li>
</ul>

<h4>Python</h4>
<pre>

# Base (Super) class definition for a k-ary tree
class Node:
	# Constructor: set the node data
	def __init__(self, key):
		self.__key   = key	# node data

	# Set Node Data
	def Key(self, key):
		self.__key = key

	# Get Node Data
	def GetKey(self):
		return __key

	# Action to perform on a node	
	def Action(self, node):
		raise NotImplementedError("Please Implement this method")

# Derived definition for a Binary Tree
class BinaryTree(Node):
	# Constructor: set the node data and left/right subtrees to null
	def __init__(self, key):
		Node.__init__(self, key)
		self.__left  = None	# left binary subtree
		self.__right = None	# right binary subtree

	# Set Left Binary Subtree
	def Left(self, left):
		self.__left = left

	# Get Left Binary Subtree
	def GetLeft(self):
		return __left

	# Set Right Binary Subtree
	def Right(self, right):
		self.__right = right

	# Get Right Binary Subtree
	def GetRight(self):
		return __right
	
	# Example action to perform on a node	
	def Action(self,node):
		print( node.key)
		
</pre>

<h4>Java</h4>
<pre>

// Base (Super) class definition for a k-ary tree
abstract class Node {
	// node data
	private Object key;
	
	// action to perform on a node
	public abstract void Action();
	
	// constructor: set the node data
	public Node( Object key ) {
		this.key = key;
	}
	
	// Set the node data
	public void Key( Object key ) {
		this.key = key;
	}
	
	// Get the node data
	public Object Key() {
		return key;
	}
}

// Derived definition for a Binary Tree
class BinaryTree extends Node {
    private BinaryTree left;	// left binary subtree
    private BinaryTree right;	// right binary subtree
	
	// Constructor: set the node data and left/right subtrees to null
	public BinaryTree (Object key) {
		super( key );
		right = null;
		left = null;
	}
	
	// Set the left binary subtree
	public void Left( BinaryTree left ) {
		this.left = left;
	}
	
	// Get the left binary subtree
	public BinaryTree Left() {
		return left;
	}
	
	// Set the right binary subtree
	public void Right( BinaryTree right ) {
		this.right = right;
	}
	
	// Get the right binary subtree
	public BinaryTree Right() {
		return right;
	}
	
	// Example action to perform on a node
	public void Action() {
		System.out.println( this.Key() );
	}
}

</pre>

<h3>7. Binary Tree Traversals</h3>

<p>
Binary trees can be traversed either breadth first or depth first. In a breadth first traversal, the tree is traversed one level at a time. 
The root node (level 1) is first visited, then the left and right node (level 2) of the root, and then the left and right nodes of these subtrees (level 3),
and so forth.
</p>
<p>
For depth first traversal or search (DFS), a tree can be traversed either inorder, preorder or postorder.
</p>
<ul>
	<li>Inorder: left (node), root, right</li>
	<li>Preorder: root, left, right</li>
	<li>Postorder: left, right, root</li>
</ul>
<p>
If you are ask questions about a binary search tree (BST), most likely the algorithm will use a postorder traversal.
</p>

<h4>Algorithm - Inorder</h4>
<ul>
	<li>From the current node (root), traverse to left node. Recursively apply algorithm to the left node.</li>
	<li>Traverse back to the root node.</li>
	<li>From the current node (root), traverse to right node. Recursively apply algorithm to the right node.</li>
</ul>

<h4>Python</h4>
<pre>

	#InOrder Traversal
	def InOrder(root):
		if root == None:
			return
		InOrder( root.left )
		Action( root )
		InOrder( root.right )
		
</pre>

<h4>Java</h4>
<pre>

	// InOrder Traversal
	public void InOrder() {
		if ( Left() != null ) Left().InOrder();
		Action();
		if ( Right() != null ) Right().InOrder();
	}
	
</pre>

<h4>Algorithm - Preorder</h4>
<ul>
	<li>Traverse to the root node.</li>
	<li>From the current node (root), traverse to left node. Recursively apply algorithm to the left node.</li>
	<li>From the current node (root), traverse to right node. Recursively apply algorithm to the right node.</li>
</ul>

<h4>Python</h4>
<pre>

	# PreOrder Traversal
	def PreOrder(root):
		if root == None:
			return
		Action( root )
		PreOrder( root.left )
		PreOrder( root.right )

</pre>

<h4>Java</h4>
<pre>

	// PreOrder Traversal
	public void PreOrder() {
		Action();
		if ( Left() != null ) Left().PreOrder();
		if ( Right() != null ) Right().PreOrder();
	}
	
</pre>

<h4>Algorithm - Postorder</h4>
<ul>
	<li>From the current node (root), traverse to left node. Recursively apply algorithm to the left node.</li>
	<li>From the current node (root), traverse to right node. Recursively apply algorithm to the right node.</li>
	<li>Traverse back to the root node.</li>
</ul>

<h4>Python</h4>
<pre>

	# PostOrder Traversal
	def PostOrder(root):
		if root == None:
			return
		PostOrder( root.left )
		PostOrder( root.right )
		Action( root )
		
</pre>

<h4>Java</h4>
<pre>

	// PostOrder Traversal
	public void PostOrder() {
		if ( Left() != null ) Left().PostOrder();
		if ( Right() != null ) Right().PostOrder();
		Action();
	}
	
</pre>

<p>
A breadth first traversal or search (BFS) traverses a tree one node level at a time, visiting each node at that level, generally from left to right.
This traversal is referred to as a level order traversal.
</p>

<h4>Algorithm - Level Order</h4>
<ul>
	<li>If the root node is non-null, add the root to the nodes to visit in sequential order.</li>
	<li>While there are nodes to visit, do:
		<ul>
			<li>Visit the next node</li>
			<li>Add the left node and right node of the visited node, if they exist to the nodes to visit.</li>
		</ul>
	</li>
</ul>

<h4>Java</h4>
<pre>

public class BFS {
	public static void BFS( BinaryTree root ) {
		
		// Check if tree is empty
		if ( root == null )
			return;
			
		// list of nodes to visit in node level order
		LinkedList<BinaryTree> visit = new LinkedList<BinaryTree>();	
		visit.add( root );
		
		// sequentially visit each node in level order as it is dynamically added to the list
		for ( int i = 0; i < visit.size(); i++ ) {
			// Perform the node action
			visit.get( i ).Action();
			
			// Add to the list the child siblings of this node
			if ( visit.get( i ).Left() != null )
				visit.add( visit.get( i ).Left() );
			if ( visit.get( i ).Right() != null )
				visit.add( visit.get( i ).Right() );
		}	
	}
	
	public static void main( String[] args ) {
		BinaryTree tree = new BinaryTree( "1" );
		tree.Left ( new BinaryTree( "2" ) );
		tree.Right( new BinaryTree( "3" ) );
		tree.Left().Left( new BinaryTree( "4" ) );
		tree.Left().Right( new BinaryTree( "5" ) );
		System.out.println( "BFS output 1 2 3 4 5");
		BFS( tree );
	}
}

</pre>

<p>
If you are asked to count the size (number of nodes) of a binary tree, using any of the traversal methods, and simply replace my call to
the method Action() with a counter that is increment each time a node is visited.
</p>

<p>You maybe asked to add to your solution a method to calculate the maximum and minimum depth of the tree. The maximum depth is the number of nodes
from the root to the leaf node that is the furthest from the root, while the minimum depth is the number of nodes
from the root to the leaf node that is the closest the root.
</p>

<h4>Algorithm - Maximum and Minimum Depth of Binary Tree</h4>
<ul>
	<li>Do a preorder traversal of the tree starting from the root.</li>
	<li>When a node is visited, increment the depth count by 1.</li>
	<li>Recursively apply the algorithm to the left and right nodes.</li>
	<li>When returning from a child back to a parent node, pass back the node depth of the child.</li>
	<li>Return the maximum or minimum value from the left and right child (or the parent if there are no children).</li>
</ul>

<h4>Java</h4>
<pre>

// Derived definition for a Binary Tree
class BinaryTree extends Node {
	...
	// Calculate the maximum depth of the binary tree
	public int MaxDepth( int max )
	{
		max++;	// increment by one level for the node
		
		int lmax = max, rmax = max;	// maximum depth on left and right nodes.
		
		// Calculate the maximum depth along the left binary subtree
		if ( Left() != null )
			lmax = Left().MaxDepth( max );
		// Calculate the maximum depth along the right binary subtree
		if ( Right() != null )
			rmax = Right().MaxDepth( max );
		
		return Math.max( lmax, rmax );
	}

	// Calculate the minimum depth of the binary tree
	public int MinDepth( int min )
	{
		min++;	// increment by one level for the node
		
		int lmin = min, rmin = min;	// minimum depth on left and right nodes.
		
		// Calculate the maximum depth along the left binary subtree
		if ( Left() != null )
			lmin = Left().MaxDepth( min );
		// Calculate the maximum depth along the right binary subtree
		if ( Right() != null )
			rmin = Right().MaxDepth( min );
		
		return Math.min( lmin, rmin );
	}
	
	// Driver method
    public static void main(String[] args)
    {
        BinaryTree tree = new BinaryTree( 1 );
        tree.Left(  new BinaryTree( 2 ) );
        tree.Right( new BinaryTree( 3 ) );
        tree.Left().Left( new BinaryTree( 4 ) );
        tree.Left().Right( new BinaryTree( 5 ) );
        System.out.println("\nMax Depth(3) is  " + tree.MaxDepth( 0 ) );
        System.out.println("\nMax Depth(2) is  " + tree.MinDepth( 0 ) );
    }
}
</pre>

<p>Another addition you maybe asked is to add to your solution a method to calculate the maximum and minimum value of the tree. The maximum
value is the node with the maximum value of all nodes, while the minimum value is the node with the minimum value of all nodes.
</p>

<h4>Algorithm - Maximum and Minimum Value</h4>
<ul>
	<li>Do a level order (Breadth First) traversal of the tree.</li>
	<li>Keep a counter of the maximum and minimum value encountered.</li>
</ul>

<h4>Java</h4>
<pre>

// Derived definition for a Binary Tree
class BinaryTree extends Node {
	...
		
	// Calculate the minimum and maximum value in the binary tree
	public int[] MinMax() {
		int min = 0x7FFFFFFF;  // counter for min value (start at maximum signed int)
		int max = 0x80000000;  // counter for max value (start at minimum signed int)
			
		// list of nodes to visit in node level order
		LinkedList<BinaryTree> visit = new LinkedList<BinaryTree>();	
		visit.add( this );
		
		// sequentially visit each node in level order as it is dynamically added to the list
		for ( int i = 0; i < visit.size(); i++ ) {
			// Perform the node action
			if ( (int)  visit.get( i ).Key() > max )
				max = (int)  visit.get( i ).Key();
			if ( (int)  visit.get( i ).Key() < min )
				min = (int)  visit.get( i ).Key();
			
			// Add to the list the child siblings of this node
			if ( visit.get( i ).Left() != null )
				visit.add( visit.get( i ).Left() );
			if ( visit.get( i ).Right() != null )
				visit.add( visit.get( i ).Right() );
		}	
		
		int[] ret = new int[2];
		ret[0] = min; ret[1] = max;
		return ret;
	}
	
	// Driver method
    public static void main(String[] args)
    {
        BinaryTree tree = new BinaryTree( 1 );
        tree.Left(  new BinaryTree( 2 ) );
        tree.Right( new BinaryTree( 3 ) );
        tree.Left().Left( new BinaryTree( 4 ) );
        tree.Left().Right( new BinaryTree( 5 ) );
		
        int[] minmax = tree.MinMax();
	    System.out.println("\nMin Value(1) is  " + minmax[ 0 ] );
	    System.out.println("\nMax Value(5) is  " + minmax[ 1 ] );
    }
	...
}
</pre>

<h3>8. k-ary Trees</h3>
<p>
As a follow up to coding examples related to a binary tree, you maybe asked to generalize a solution for a k-ary tree. A k-ary tree is a tree
that may at most k children. You may be challenged, by being asked to create a base (super) class from which any k-ary tree can derived (extended)\
from, with the condition that the children (branch) members must be defined in the base (super) class.
</p>
<p>
Since we do not know in the base (super) class how many children (branches) each node will have, we will use a dynamic array to represent the
member for children. In the Java coding example, I will use the predefined dynamic array type ArrayList.
</p>

<h4>Algorithm</h4>
<ul>
	<li>The base class defines the key member and corresponding access methods.</li>
	<li>The base class defines a member for the maximum number of children and a dynamic array for pointers to the children.</li>
	<li>The base class is made abstract, so that one has to derive (extend) a class to use it.</li>
	<li>An abstract method (must be defined in derived class) is added to defining an action to perform on each node in the tree that is
			specific to a derived class.</li>
	<li>The base class defines a Add() method for adding a child (branch) to the node.</li>
	<li>The base class defines a Children() method for accessing all the children (branches) of the node.</li>
</ul>

<h4>Java</h4>
<pre>

import java.util.ArrayList;

// Base (Super) class definition for a k-ary tree
abstract class KNode {
	// node data
	private Object key;
	// max number of children
	private final int k;
	
	// Dynamic array for children
	private ArrayList<KNode> children = new ArrayList();
	
	// action to perform on a node
	public abstract void Action();
	
	// constructor: set the node data
	public KNode( int k, Object key ) {
		this.key = key;
		this.k   = k;
	}
	
	// Set the node data
	public void Key( Object key ) {
		this.key = key;
	}
	
	// Get the node data
	public Object Key() {
		return key;
	}
	
	// Get the number of children
	public int Size() {
		return children.size();
	}
	
	// Add another child (branch)
	public KNode Add( Object key ) {
		// exceeds number of allowed children
		if ( Size() == k )
			return null;
		Tree e = new Tree( k, key );
		children.add( e );
		return e;
	}
	
	// Get all the children of this node
	public ArrayList<KNode> Children() {
		return children;
	}
}

// Definition for a k-ary tree
class Tree extends KNode {
	public Tree( int k, Object key ) {
		super( k, key );
	}
	
	public void Action() {
		// do something
	}
}
</pre>

<h3>9. Binary Search Tree</h3>
<p>
A binary search tree (BST) is a sorted tree where at each node, the data value of the left branch (child) is less than the data value of the node, and the right
node is greater than, and where there are no duplicate values. For example, if the data value of the root node is 5, and we added a node with value 3 it
would be inserted on the left branch, while a node of 7 would be inserted on the right branch.
</p>

<p>
You maybe asked to code the algorithm to insert, find and delete nodes a binary search tree.
</p>

<h4>Algorithm - Insert</h4>
<ul>
	<li>If the root node is null, make the root the node</li>
	<li>Otherwise, starting at the root, traverse the tree:
		<ul>
			<li>If the node is equal to the current node, then return (duplicate)</li>
			<li>If the node is less than the current node.
				<ul>
					<li>If the left node is null, then make the node the left node.</li>
					<li>Otherwise, traverse to the left node.</li>
				</ul>
			</li>
			<li>If the node is greater than the current node.
				<ul>
					<li>If the right node is null, then make the node the right node.</li>
					<li>Otherwise, traverse to the right node.</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

<h4>Java</h4>
<pre>

// Definition for a binary search tree
class BST {
	public BinaryTree root = null;	// root of the binary search tree
	
	// Insert a node into a binary tree
	public void Insert( BinaryTree node ) {
		// Empty Tree, make the node the root
		if ( root == null ) {
			root = node;
			return;
		}
		
		// Follow a path to insert the node
		BinaryTree curr = root;
		while ( true ) {
			// node is a duplicate, do not insert
			if ( (int) node.Key() == (int) curr.Key() ) {
				return;
			}
			
			// The node is less than the current node, traverse left
			if ( (int) node.Key() < (int) curr.Key() ) {
				// If there is no left node, make this node the left node
				if ( curr.Left() == null ) {
					curr.Left( node );
					return;
				}
				curr = curr.Left();
			}
			// The node is greater than to the current node, traverse left
			else {
				// If there is no right node, make this node the right node
				if ( curr.Right() == null ) {
					curr.Right( node );
					return;
				}
				curr = curr.Right();
			}
		}
	}
	
	// Driver method
    public static void main(String[] args)
    {
        BST tree = new BST();
		System.out.println("BST level order: 3 2 6 1 4");
		tree.Insert( new BinaryTree( 3 ) );
		tree.Insert( new BinaryTree( 6 ) );
		tree.Insert( new BinaryTree( 2 ) );
		tree.Insert( new BinaryTree( 4 ) );
		tree.Insert( new BinaryTree( 1 ) );
		BFS( tree.root );
	}
}

</pre>

<h4>Algorithm - Find</h4>
<ul>
	<li>Starting at the root, traverse a path in the tree.</li>
	<li>If the current node is null, return not found.</li>
	<li>If the value is equal to the current node, return found.</li>
	<li>If the value is less than the current node, traverse to the left node.</li>
	<li>Otherwise (the value is greater than the current node), traverse to the right node.</li>
</ul>

<h4>Java</h4>
<pre>

// Definition for a binary search tree
class BST {
	...
	
	// Find a node in a binary tree
	public BinaryTree Find( Object key ) {
			
		// Follow a path to find the node
		BinaryTree curr = root;
		while ( true ) {
			// current node is null, return null (not found)
			if ( curr == null )
				return null;
				
			// the value is equal to the current node, return the current node
			if ( (int) key == (int) curr.Key() ) {
				return curr;
			}
			
			// The value is less than the current node, traverse left
			if ( (int) key < (int) curr.Key() ) {
				curr = curr.Left();
			}
			// The value is greater than to the current node, traverse left
			else {
				curr = curr.Right();
			}
		}
	}
	
	// Driver method
	public static void main(String[] args)
	{
        BST tree = new BST();
		tree.Insert( new BinaryTree( 3 ) );
		tree.Insert( new BinaryTree( 6 ) );
		tree.Insert( new BinaryTree( 2 ) );
		tree.Insert( new BinaryTree( 4 ) );
		tree.Insert( new BinaryTree( 1 ) );
		System.out.println( "FIND(4) = " + tree.Find( 4 ) + " FIND(0) = " + tree.Find(0) );
	}
}

</pre>

<h4>Algorithm - Delete</h4>
<ul>
	<li>Traverse the tree, starting with the root and remember the previous node visited.</li>
	<li>If the current node is null, return (not found).</li>
	<li>If the value is equal to the current node.
		<ul>
			<li>If the node is the left node of the previous node, set the previous node's left node to null.</li>
			<li>Otherwise (is the right node of the previous node), set the previous node's right node to null.</li>
			<li>Remember the root and temporarily set the root to the previous node.</li>
			<li>If the left node of the current (deleted) node is non-null, then Insert() the current node's left node back into the tree.</li>
			<li>If the right node of the current (deleted) node is non-null, then Insert() the current node's right node back into the tree.</li>
		</ul>
	</li>
	<li>If the value is less than the current node.
		<ul>
			<li>Set flag that the current node is the left node of the current node.</li>
			<li>Set the previous node to the current node.</li>
			<li>Set the current node to the left node of the previous node.</li>
		</ul>
	</li>
	<li>Otherwise (value is greater than the current node).
		<ul>
			<li>Set flag that the current node is the right node of the current node.</li>
			<li>Set the previous node to the current node.</li>
			<li>Set the current node to the right node of the previous node.</li>
		</ul>
	</li>
</ul>

<h4>Java</h4>
<pre>

// Definition for a binary search tree
class BST {
	...
	
	// Find a node in a binary tree
	public void Delete( Object key ) {

		// Follow a path to find the node
		BinaryTree curr = root, prev = null;
		boolean isLeft = false;
		while ( true ) {
			// current node is null, return (not found)
			if ( curr == null )
				return;
				
			// the value is equal to the current node, delete the node
			if ( (int) key == (int) curr.Key() ) {
				if ( isLeft ) 
					prev.Left( null );
				else
					prev.Right( null );
				BinaryTree saveRoot = root;
				root = prev;
				if ( curr.Left()  != null ) Insert( curr.Left() );
				if ( curr.Right() != null ) Insert( curr.Right() );
				root = saveRoot;
				return;
			}
			else if ( (int) key < (int) curr.Key() ) {
				isLeft = true;
				prev = curr;
				curr = curr.Left();
			}
			else {
				isLeft = false;
				prev = curr;
				curr = curr.Right();
			}
		}
	}
	
	// Driver method
    public static void main(String[] args)
    {
        BST tree = new BST();
		tree.Insert( new BinaryTree( 3 ) );
		tree.Insert( new BinaryTree( 6 ) );
		tree.Insert( new BinaryTree( 2 ) );
		tree.Insert( new BinaryTree( 4 ) );
		tree.Insert( new BinaryTree( 1 ) );
		tree.Delete( 6 );
		System.out.println("BST level order: 3 2 4 1");
		BFS( tree.root );
	}
}
	
</pre>

<h3>10. Arithmetic Operations</h3>
<p>
A very basic arithmetic problem you maybe asked is to implement a multiply operation where you can only use the addition and equality operator.
</p>

<h4>Algorithm - Multiply</h4>
<ul>
	<li>Initialize accumulators for result and repeat to 0.</li>
	<li>Loop indefinitely for 'x + y'</li>
	<ul>
		<li>If the repeat accumulator equals y, then break.</li>
		<li>Increment the repeat accumulator by one. </li>
		<li>Add x to the result accumulator.</li>
	</ul>
</ul>

<h4>Python</h4>
<pre>

# Multiple using only + and = operator
def Mul( x, y ):
	result = 0  # accumlator for the result
	repeat = 0  # accumlator for the number of times to repeat the addition
		
	while ( True ):
		# starting at zero, exit the loop after y+1 times
		repeat += 1
		if repeat == y + 1:
			break
		# accumulate the result by adding x to the accumulator
		result += x;

	return result

print( Mul( 5, 6 ) )

</pre>

<h4>Java</h4>
<pre>

public class Calc
{
	// Multiple using only + and = operator
	public static int Mul( int x, int y ) {
		int result = 0;	// accumlator for the result
		int repeat = 0;	// accumlator for the number of times to repeat the addition
		
		while ( true ) {
			// starting at zero, exit the loop after y+1 times
			if ( repeat++ == y )
				break;
			// accumulate the result by adding x to the accumulator
			result += x;
		}
		return result;
	}
	
	public static void main(String[] args) {
		System.out.println( "5 * 6 = " + Mul( 5, 6 ) );
	}
}

</pre>

<p>
You would then be likely asked to extend the solution to include an exponent operation where you can only use the addition and equality operator.
</p>

<h4>Algorithm - Exponent</h4>
<ul>
	<li>If the exponent is zero, return 1.</li>
	<li>Initialize accumulators for result to 1 and repeat to 0.</li>
	<li>Loop indefinitely for 'x power e'</li>
	<ul>
		<li>If the repeat accumulator equals e, then break.</li>
		<li>Increment the repeat accumulator by one. </li>
		<li>Update the result accumulator to Mul(x, result).</li>
	</ul>
</ul>

<h4>Python</h4>
<pre>

....
# Exponent using only + and = operator
def Exp( x, e ):
	# x raised to power of 0 is always 1
	if e == 0:
		return 1
		
	result = 1	# accumlator for the result
	repeat = 0	# accumlator for the number of times to repeat the multiplication
	while ( True ):
		repeat += 1
		if repeat == e + 1:
			break
		result = Mul( x, result );

	return result

print( Exp( 3, 4 ) )

</pre>

<h4>Java</h4>
<pre>

public class Calc
{
	...
	
	// Exponent using only + and = operator
	public static int Exp( int x, int e ) {
		// x raised to power of 0 is always 1
		if ( e == 0 )
			return 1;
		
		int result = 1;	// accumlator for the result
		int repeat = 0;	// accumlator for the number of times to repeat the multiplication
		while ( true ) {
			if ( repeat++ == e )
				break;
			result = Mul( x, result );
		}
		return result;
	}
	
	public static void main(String[] args) {
		System.out.println( "3 exp 4 = " + Exp( 3, 4 ) );
	}
}

</pre>

<p>Another algorithm you may be asked to code is Euclid's algorithm for find the great common denominator between two numbers. The algorithm
dates back to 300BC. It is a very efficient algorithm that involves a few small steps. It can be coded as iteratively or recursively.
</p>

<h4>Algorithm - GCD Iterative Solution</h4>
<ul>
	<li>Calculate the remainder of dividing the 2nd number by the first number (y % x)</li>
	<li>Swap the value of the first number (x) with the second number (y).</li>
	<li>Set the second number (y) to the remainder.</li>
	<li>Iteratively repeat the process until the 2nd number (y) is zero.</li>
	<li>Return the value of first number (x) when the 2nd number is zero (y).</li>
</ul>

<h4>Java</h4>

<pre>

public class GCD {
	// Euclid's algorithm as an iterative solution
	private static int GCD( int x, int y )
	{
		// continue until the division of of the two numbers does not leave a remainder (evenly divisible)
		while ( y > 0 )
		{
			// calculate the remainder of the division by between x and y
			int remainder = ( y % x );
			
			// swap the value of x with y
			x = y;
			
			// set y to the remainder
			y = remainder;
		}
		
		return x;
	}
	
	public static void main(String[] args ) {
		System.out.println( "GCD(4) " + GCD( 12, 16 ) );
	}
}

</pre>

<p>
You may then be asked to code the solution using recursion.
</p>

<h4>Algorithm - GCD Recursive Solution</h4>
<ul>
	<li>When the 2nd number (y) is reduced to zero, return the current value of the first number (x)</li>
	<li>Otherwise, swap the first number (x) with the second number (y) and set the 2nd number (y) to the remainder
	of the division of the 2nd number by the first number (x % y).</li>
	<li>Recursively call GCD() with the updated first and second numbers.</li>
</ul>

<h4>Java</h4>
<pre>

public class GCD {
	// Euclid's algorithm as a recursive solution
	private static int GCD( int x, int y )
	{
		// return the current value of x when y is reduced to zero.
		if ( y == 0 )
			return x;
			
		return GCD( y, ( y % x ) );
	}
	
	public static void main(String[] args ) {
		System.out.println( "GCD(4) " + GCD( 12, 16 ) );
	}
}

</pre>

<p>
Finally, you may also be asked to extend your solution to additionally find the least common multiple (denominator). The least common multiple (LCM) is the
product of the two numbers divided by the GCD of the two numbers.
</p>

<h4>Algorithm - LCM</h4>
<ul>
	<li>Multiple the first and second number.</li>
	<li>Divide the result by the GCD of the two numbers.</li>
</ul>

<h4>Java</h4>
<pre>

public class GCD {
	...
	// Calculate the least common mulitple
	private static int LCM( int x, int y )
	{
		return ( x * y ) / GCD( x, y );
	}
	
	public static void main(String[] args ) {
		System.out.println( "LCM(24) " + LCM( 6, 8 ) );
	}
}

</pre>

<h3>11. Variable Length Byte Encoding</h3>
You maybe asked to code a variable length byte encoding, using the least amount of bits for the encoding across all sequences. For example, some
encodings will be one byte, some two bytes, etc. In an encoding with between 1 and 8 bytes, if we restrict the first byte to must contain a zero
bit, then we can use the position of the zero bit to determine the byte length, while retaining the use of the less significant bits for the
encoding.
</p>

<h4>Algorithm</h4>
<ul>
	<li>If the most significant bit is zero, then the encoding is one byte long and the remaining bits are the encoding.</li>
	<li>If the most significant bit is one, the bit position (most to least significant) is the number of bytes in the encoding,
	and the remaining less significant bits in the first byte and all the bits in the remaining bytes are the encoding.
	</li>
</ul>

<h4>Java</h4>
<pre>

public class Encoding {
	public static int Size( byte[] encoding ) {
		byte first = encoding[ 0 ];
		// checking leading bit
		if ( ( first & 0x80 ) == 0 )
			return 1;
		if ( ( first & 0x40 ) == 0 )
			return 2;
		if ( ( first & 0x20 ) == 0 )
			return 3;
		if ( ( first & 0x10 ) == 0 )
			return 4;
		if ( ( first & 0x08 ) == 0 )
			return 5;
		if ( ( first & 0x04 ) == 0 )
			return 6;
		if ( ( first & 0x02 ) == 0 )
			return 7;
		if ( ( first & 0x01 ) == 0 )
			return 8;
		return 0;	// error
	}
	
	public static void main(String[] args) {
		byte[] encoding = new byte[8];
		encoding[ 0 ] = (byte) 0x49;
		System.out.println( "Size(1) = " + Size( encoding ) );
		encoding[ 0 ] = (byte) 0x89;
		System.out.println( "Size(2) = " + Size( encoding ) );
		encoding[ 0 ] = (byte) 0xCB;
		System.out.println( "Size(3) = " + Size( encoding ) );
	}
}

</pre>

<h3>12. Sorting</h3>
<p>
There are numerous basic algorithms for sorting. You may get asked to start with a simple sort algorithm and progressively code more complex
algorithms. One simple algorithm is a bubble sort. It works by going through a list and comparing adjacent values, and swapping them if the first
value is greater than the second value (ascending) or vice-versa (descending). Repeated passes are made through the list until no values are
swapped. The term bubble sort comes from the concept that the smaller (or larger) values slowly bubble up. The performance is poor and has
a time complexity of O(n*n).
</p>

<h4>Algorithm - Bubble Sort</h4>
<ul>
	<li>Make a pass through the list of values.
		<ul>
			<li>Compare adjacent values.</li>
			<li>If the first value is less than the second value, swap the values.</li>
		</ul>
	</li>
	<li>If one of more values were swapped, repeat the process of making a pass through the list.</li>
</ul>

<h4>Java</h4>
<pre>

class Sort {
	// Definition for a Bubble Sort
	public static int[] BubbleSort( int[] data ) {
		boolean swapped = true;
		// continue to repeat until no more adjacent values are swapped
		while ( swapped ) {
			swapped = false;
			// Make a scan through the list
			for ( int i = 0; i < data.length - 1; i++ ) {
				// Compare adjacent values. If the first value > second value, swap the values.
				if ( data[ i ] > data[ i + 1 ] ) {
					int swap = data[ i ];
					data[ i ] = data[ i + 1 ];
					data[ i + 1 ] = swap;
					swapped = true;
				}
			}
		}
		return data;
	}
	
	public static void main( String[] args ) {
		int[] data = new int[ 6 ];
		data[ 0 ] = 5; data[ 1 ] = 2; data[ 2 ] = 4; data[ 3 ] = 1; data[ 4 ] = 6; data[ 5 ] = 3;
		data = BubbleSort( data );
		for ( int i = 0; i < data.length; i++ )
			System.out.println( data[ i ] );
	}
}

</pre>

<p>Another simple sorting algorithm you maybe asked to code is an insertion sort. It makes N iterations on the list of elements. 
On each iteration it advances to the next element and inserts the element into the correct position in the list. It's performance is good
on small sets, but poor on large sets with a time complexity of O(n*n).
</p>

<h4>Algorithm - Insertion Sort</h4>
<ul>
	<li>Iterate through the list of elements.
		<ul>
			<li>Remove and Insert the element into the correct position in the list 
			of elements proceeding it.</li>
		</ul>
	</li>
</ul>

<h4>Java</h4>
<pre>

class Sort {
	// Definition for an Insertion Sort
	public static int[] InsertionSort( int[] data ) {
		// iterate through the list for each element except the first element
		for ( int i = 1; i < data.length; i++ ) {
			// starting with the current element, remove/insert proceeding
			// elements so they are in sorted order
			for ( int j = i; j > 0; j-- ) {
				// swap adjacent elements
				if ( data[ j ] < data[ j - 1 ] ) {
					int temp = data[ j ];
					data[ j ] = data[ j -1 ];
					data[ j - 1 ] = temp;
				}
			}
		}
		return data;
	}
	
	public static void main( String[] args ) {
		int[] data = new int[ 6 ];
		data[ 0 ] = 5; data[ 1 ] = 2; data[ 2 ] = 4; data[ 3 ] = 1; data[ 4 ] = 6; data[ 5 ] = 3;
		data = InsertionSort( data );
		for ( int i = 0; i < data.length; i++ )
			System.out.println( data[ i ] );
	}
}
	
</pre>

<footer>
<br/>
Best Regards,<br/>
Andrew Ferlitsch<br/>
Portland Data Science Group, Co-Organizer
</footer>
</body>
</html>
